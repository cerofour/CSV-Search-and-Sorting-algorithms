package pe.edu.utp.csvsorterandsearcher.CSV;

import java.io.*;
import java.util.ArrayList;

/***
 * CSVReader class. The job of this class is to create an intermediate representation
 * of the CSV file suitable and efficient for sorting algorithms.
 */
public class CSVReader {
    FileInputStream file;

    BufferedReader reader;

    boolean useFileHeaders;
    boolean atEof;

    // type-check values on every iteration of the reading proccess
    // if false, the reader will type-check the values everytime it reads a line
    // from the CSV
    boolean alwaysTypeCheck;

    String[] csvHeaders;
    FieldType[] types;

    // by default a comma (",")
    String valueSeparator;

    public CSVReader(File fi) {
        try {
            file = new FileInputStream(fi);
            reader = new BufferedReader(new InputStreamReader(file));
            useFileHeaders = true;
            csvHeaders = null;
            atEof = false;
            valueSeparator = ",";
            alwaysTypeCheck = false;
        } catch (IOException e) {
            System.err.println(e.getMessage());
        }
    }

    public void useFileHeaders() {
        useFileHeaders = true;
    }

    public void useAutoGeneratedHeaders() {
        useFileHeaders = false;
    }

    private String nextLine() {
        if (atEof)
            return null;

        try {
            String line = reader.readLine();
            if (line == null)
                atEof = true;
            return line;
        } catch (java.io.IOException e) {
            System.err.println("Exception thrown while reading file: " + e.getMessage());
            System.exit(-1);
        }

        // unreachable
        return null;
    }

    private String[] nextRow() {
        String line = nextLine();
        if (atEof || line == null)
            return null;

        String[] row = line.split(valueSeparator);

        return row;
    }

    private void generateHeaders() {

        String[] row = nextRow();
        if (row == null) // empty file
            return;

        // maybe handle the edge case where the first line is ""
        // but I don't think our professor is that evil

        // expects this.reset to be at the start of the file
        if (useFileHeaders) {
            csvHeaders = row;
        } else {
            csvHeaders = new String[row.length];
            for (int i = 0; i < row.length; i++)
                csvHeaders[i] = String.format("C%d", i);
        }

        types = new FieldType[csvHeaders.length];
    }

    private void typeCheck(String[] row) {

        assert(row.length <= csvHeaders.length);

        for (int i = 0; i < Math.min(csvHeaders.length, row.length); i++)
            types[i] = DataTypeDetector.dataTypeDetector(row[i]);
    }

    /**
     * @brief Reads the whole CSV file and creates the intermediate representation.
     *          Right now the reader doesn't perform any error checking on the file. That
     *          is, the file may have rows with a number of values different from the number of
     *          headers, such thing may cause a loss of data or a IndexOutOfBound exception.
     *          Edge cases like the one mentioned above may be considered if necessary.
     */
    public CSVIntermediateRepresentation readWholeFile() {
        //resetReader();

        generateHeaders();

            ArrayList<ArrayList<String>> table = new ArrayList<>();
            FieldType[] types = new FieldType[csvHeaders.length];
            int[] maxLengths = new int[csvHeaders.length];

        for (int i = 0; i < csvHeaders.length; i++)
            table.add(new ArrayList<>());


        CSVIntermediateRepresentation ir = new CSVIntermediateRepresentation(csvHeaders, null);

        String[] lastRow = null;

        for (String[] row = nextRow(); !atEof || row != null; row = nextRow()) {
            assert Math.min(csvHeaders.length, row.length) == csvHeaders.length;

            if (alwaysTypeCheck)
                typeCheck(row);

            for (int i = 0; i < csvHeaders.length; i++) {
                if (row[i].length() > maxLengths[i])
                    maxLengths[i] = row[i].length();
                table.get(i).add(row[i]);
            }

            lastRow = row;
        }

        typeCheck(lastRow);

        String[][] tableArray = new String[csvHeaders.length][];
        // now convert the double ArrayList to a String[][]
        for (int i = 0; i < csvHeaders.length; i++) {
            tableArray[i] = table.get(i).toArray(new String[0]);
        }

        ir.setTable(tableArray);
        return ir;
    }
}
